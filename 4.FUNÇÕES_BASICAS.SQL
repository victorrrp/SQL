--UTILIZANDO FUNÇÕES BASICAS

SELECT NOME FROM TALUNO;

--CONCATENAÇÃO
SELECT CONCAT(COD_ALUNO,NOME) FROM TALUNO;

--MANEIRA SIMPLIFICADA
SELECT COD_ALUNO||NOME FROM TALUNO;

--ALTERANDO A COLUNA COM CONCATENAÇÃO
SELECT COD_ALUNO||' - '|| NOME FROM TALUNO;


--INITCAP - TRANFORMA TODAS AS PRIMEIRAS LETRAS DAS PALAVRAS EM MAIUSCULAS
--CONSEQUENTEMENTE O RESTO EM MINUSCULAS (INDICADO PARA FORMATAÇÕES)
SELECT NOME, INITCAP(NOME) FROM TALUNO;


--INSTR - RETORNA A LOCALIZAÇÃO DA LETRA PRÉ-SELECIONADA NA TABELA
SELECT NOME, INSTR(NOME, 'R') FROM TALUNO;


--LENGTH - RETORNA QUANTOS CARACTERES TEM EM CADA ITEM DA TABELA
SELECT NOME, LENGTH(NOME) FROM TALUNO;


--LOWER - RETORNA OS ITENS DA TABELA COM LETRAS MINUSCULAS
SELECT NOME, LOWER(NOME) FROM TALUNO;


--UPPER - RETORNA OS ITENS DA TABELA COM LETRAS MAIUSCULAS
SELECT NOME, UPPER(NOME) FROM TALUNO;


--UTILIZANDO INITCAP COM TEXTO FIXO
SELECT INITCAP('JOSUE DA SILVA') FROM DUAL;


--LPAD - APRESENTA, DA ESQUERDA PARA DIREITA, O ITEM DE FORMA ORGANIZADA, RESPEITANDO A QTD DE CARACTERES
SELECT COD_ALUNO, LPAD(COD_ALUNO, 4, '0') FROM TALUNO;

--RPAD - O MESMO QUE O LPAD, SÓ QUE DA DIREITA PARA ESQUERDA. UTILIZADO PARA VARIAVEIS TEXTO, POIS O NUMERO A DIREITA ALTERA O VALOR
SELECT NOME, RPAD(NOME, 10, '/') FROM TALUNO;


--SUBSTR - COPIA PARTE DE UM TEXTO. SUBSTRING
SELECT NOME, SUBSTR(NOME,1,3) FROM TALUNO;

SELECT NOME, SUBSTR(NOME,3,1) FROM TALUNO;


--REPLACE - SUBSTITUI UM DETERMINADO CARACTER NO ITEM DA TABELA (PARA ALTERAÇÃO COMPLETA, UTILIZE UPDATE)
SELECT NOME, REPLACE(NOME, 'I', '1') FROM TALUNO;


--RETORNANDO O ULTIMO CARACTER DO ITEM UTILIZANDO LENGTH E SUBSTR
--LENGTH PARA ACESSAR QUANTOS CARACTERES TEM NO ITEM E SUBSTR PARA COPIA-LO
SELECT NOME, SUBSTR(NOME,LENGTH(NOME),1)FROM TALUNO; 

--CONTROLANDO QUANTOS CARACTERES DEVEM APARECER EM CADA ITEM
SELECT NOME, SUBSTR(NOME, 3, LENGTH(NOME) -3) FROM TALUNO;


--BUSCANDO NOME NA LISTA EVITANDO CONFLITO DE MAIUSCULAS E MINUSCULAS
SELECT * FROM TALUNO
WHERE LOWER(NOME) = 'victor';

SELECT * FROM TALUNO
WHERE UPPER(NOME) = 'VICTOR';


--BUSCANDO CIDADE NA LISTA POR CARACTERES 
--UTILIZA-SE O UPPER PARA EVITAR QUALQUER CONFLITO ENTRE MAIUSCULAS E MINUSCULAS
SELECT * FROM TALUNO
WHERE UPPER(SUBSTR(CIDADE,1,3)) = 'CAN';


--ALTERANDO SALARIO DE UM ALUNO NA TABELA
UPDATE TALUNO SET
SALARIO = 633.47
WHERE COD_ALUNO = 1;


--FAZENDO MODIFICACOES EM 'SALARIO'
SELECT
  SALARIO,
  REPLACE(SALARIO, ',',''),               --SUBSTITUINDO A VIRGULA POR ESPAÇO VAZIO
  RPAD(SALARIO, 10, '0'),                 --ZEROS A DIREITA ATÉ 10 CASAS
  LPAD(SALARIO, 10, '0'),                 --ZEROS A ESQUERDA ATE 10 CASAS
  LPAD(REPLACE(SALARIO, ',',''), 10,'0')  --JUNTANDO REPLACE COM LPAD PARA MANTER OS ITENS ORGANIZADOS
FROM TALUNO;


--TRABALHANDO COM DATAS
SELECT * FROM DUAL;


--SYSDATE -> FUNÇÃO QUE RETORNA DATA/HORA DO SERVIDOR
SELECT SYSDATE FROM DUAL;


--UTILIZANDO ROUND E TRUNC
SELECT ROUND(45.925, 2), --ARREDONDA VALOR (PARA CIMA)
       TRUNC(45.929, 2), --ARREDONDA VALOR (PARA BAIXO)
       MOD(10, 2) AS RESTO_DIVISAO,
       TRUNC(1.99),      
       TRUNC(1.99, 1)    --UTILIZA-SE O UM NUMERO FIXO DENTRO DA FUNÇÃO PARA DETERMINAR QUANTAS CASAS DECIMAIS FICARÃO APÓS A VIRGULA
FROM DUAL;


SELECT * FROM TCONTRATO;


--FUNÇÕES DATA E HORA
SELECT DATA, SYSDATE, DATA + 5 FROM TCONTRATO; 

--DIFERENÇA DE DIAS (CASO NÃO SEJA COLOCADO O TRUNC, APARECERÁ O NUMERO INTEIRO DA DIFERENÇA. ARRENDONDE O VALOR)
SELECT TRUNC(SYSDATE - DATA) AS DIF_DIAS FROM TCONTRATO;

--MOSTRANDO DATA SOMANDO HORAS
SELECT SYSDATE, SYSDATE + 2/24 AS ADD_HORAS FROM TCONTRATO;

--MOSTRANDO DATA SOMANDO MINUTOS
SELECT SYSDATE, SYSDATE + 15/1440 AS ADD_MINUTOS FROM TCONTRATO;

--MOSTRANDO DATA SOMANDO SEGUNDOS
SELECT SYSDATE, SYSDATE + 30/(3600*24) AS ADD_SEGUNDOS FROM TCONTRATO;


--BUSCANDO REGISTROS DE DATA IGNORANDO AS HORAS
SELECT SYSDATE, TRUNC(SYSDATE) FROM DUAL;


--MOSTRANDO DIFERENÇA DE MESES ENTRE DATAS
SELECT MONTHS_BETWEEN (SYSDATE, SYSDATE - 90) AS DIF_MESES FROM DUAL;


--ADICIONANDO MESES NA DATA
SELECT ADD_MONTHS(SYSDATE, 5) AS ADICIONA_MES_DATA FROM DUAL;


--PROXIMA DATA A PARTIR DE UM DIA DA SEMANA
SELECT NEXT_DAY(SYSDATE, 'QUARTA-FEIRA') AS PROXIMA_QUARTA_DATA FROM DUAL;


--DATA DO ULTIMO DIA DO MES
SELECT LAST_DAY(SYSDATE) AS ULTIMO_DIA_MES FROM DUAL;


/*TRAZENDO O PRIMEIRO DIA DO PROXIMO MES
UTILIZANDO ROUND SERÁ MOSTRADO ATÉ O DIA 15, O PRIMEIRO DIA DO MES ATUAL
A PARTIR DO DIA 16, RETORNA O PRIMEIRO DIA DO PROXIMO MES*/
SELECT ROUND(SYSDATE, 'MONTH') AS PRIMEIRO_DIA_PROXIMO_MES FROM DUAL;


--UTILIZANDO TRUNC, SERÁ RETORNADO SEMPRE O PRIMEIRO DIA DO MES CORRENTE
SELECT TRUNC(SYSDATE, 'MONTH') AS PRIMEIRO_DIA_MES_CORRENTE FROM DUAL;



--FORMATAÇAO DE DATA
--CONVERSOR TO_CHAR(DATA, FORMATO)

--MOSTRANDO DIA DO MES
SELECT SYSDATE, TO_CHAR(SYSDATE, 'DD') FROM DUAL;


--MOSTRANDO SOMENTE A DATA, SEM HORA, MAS UTILIZANDO O TO_CHAR
SELECT TO_CHAR(SYSDATE, 'DD,MM,YYYY') DATA FROM DUAL;

--SOMENTE DIA E MES
SELECT TO_CHAR(SYSDATE, 'DD,MM') DIA_MES FROM DUAL;

--SOMENTE DIA
SELECT TO_CHAR(SYSDATE, 'DD') DIA FROM DUAL;

--SOMENTE MES
SELECT TO_CHAR(SYSDATE, 'MM') MES FROM DUAL;

--SOMENTE ANO
SELECT TO_CHAR(SYSDATE, 'YYYY') ANO FROM DUAL;

--BUSCANDO MES (NOME DO MES)
SELECT TO_CHAR(SYSDATE, 'MONTH') MES1 FROM DUAL;

--BUSCANDO DIA DA SEMANA
SELECT TO_CHAR(SYSDATE, 'D') DIA_SEMANA FROM DUAL;

--BUSCANDO DIA DA SEMANA (NOME DO DIA SIMPLIFICADO)
SELECT TO_CHAR(SYSDATE, 'DY') DIA_SEMANA FROM DUAL;

--BUSCANDO DIA DA SEMANA (NOME COMPLETO)
SELECT TO_CHAR(SYSDATE, 'DAY') DIA_SEMANA1 FROM DUAL;

--BUSCANDO O ANO (POR EXTENSO)
SELECT TO_CHAR(SYSDATE, 'YEAR') ANO FROM DUAL;

--BUSCANDO DATA (POR EXTENSO)
SELECT TO_CHAR(SYSDATE, '"NOVO HAMBURGO", FMDAY "," DD "DE" FMMONTH "DE" YYYY') AS CIDADE_DATA FROM DUAL;

--BUSCANDO SOMENTE HORA E MINUTO
SELECT TO_CHAR(SYSDATE,'HH24:MI') HORA_MIN FROM DUAL;

--BUSCANDO HORA, MINUTO E SEGUNDO
SELECT TO_CHAR(SYSDATE, 'HH24:MI:SS') HORA_MIN_SEG FROM DUAL;

--BUSCANDO DATA E HORA
SELECT TO_CHAR(SYSDATE, 'DD/MM HH24:MI') DATA_HORA FROM DUAL;


--OUTRAS FORMAS DE UTILIZAR O TO_CHAR PARA FORMATACAO
--L -> R$
--G -> PONTO
--D -> CASAS DECIMAIS


--FORMATANDO SALARIO (DUAS FORMAS DE SE OBTER O MESMO RESULTADO FINAL. TRIM = RETIRA OS ESPAÇOS EM BRANCO)
SELECT TRIM(TO_CHAR(SALARIO, 'L99999.99')) AS SALARIO1, TRIM(TO_CHAR(SALARIO,'L99G999D99')) AS SALARIO2 FROM TALUNO;


--OUTRA FORMA DE FORMATAR OBTENDO O MESMO RESULTADO
SELECT 'R$ '||(ROUND(SALARIO,2)) AS SALARIO FROM TALUNO;



/*NVL ->A FUNÇÃO NVL() RECEBE DOIS PARÂMETROS, 
O PRIMEIRO É O VALOR USADO NA CONDIÇÃO, O SEGUNDO É O VALOR DEFAULT A SER USADO QUANDO VALOR FOR NULL

NVL2 ->JÁ A FUNÇÃO NVL2 RECEBE TRÊS PARÂMETROS, 
O PRIMEIRO É O VALOR USADO NA CONDIÇÃO, O SEGUNDO SERÁ O RESULTADO DA CONSULTA 
QUANDO O VALOR NA CONDIÇÃO FOR NOT NULL, E O TERCEIRO QUANDO FOR NULL*/


SELECT * FROM TCONTRATO;

SELECT TOTAL,
       DESCONTO,
       DESCONTO+TOTAL,
       NVL(DESCONTO,0),
       NVL(DESCONTO,0) + TOTAL,
       NVL2(DESCONTO, TOTAL, -1)
FROM TCONTRATO;


--PODE-SE USAR O NVL COM TEXTO TAMBEM, NÃO SOMENTE NUMEROS
SELECT * FROM TALUNO

UPDATE TALUNO SET 
NOME = NULL 
WHERE COD_ALUNO = 5;

SELECT COD_ALUNO, NVL(NOME, 'SEM NOME') FROM TALUNO;


--UTILIZANDO CASE, WHEN ('CASO QUANDO')
SELECT NOME, ESTADO,
       CASE
         WHEN ESTADO = 'RS' THEN 'GAUCHO'
         WHEN ESTADO = 'AC' THEN 'ACREANO'
         WHEN ESTADO = 'RJ' AND SALARIO > 500 THEN 'CARIOCA'
         ELSE 'OUTROS'
       END AS APELIDO
FROM TALUNO;


--UTILIZANDO DECODE - BASICAMENTE A MESMA FUNÇÃO DO CASE, SÓ QUE DE FORMA MAIS SIMPLIFICADA
SELECT NOME, ESTADO,
       DECODE(ESTADO, 'RS', 'GAUCHO',
                      'AC', 'ACREANO',
                      'RJ', 'CARIOCA',
                            'OUTROS') AS APELIDO
FROM TALUNO;





